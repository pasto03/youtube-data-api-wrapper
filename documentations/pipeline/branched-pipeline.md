> **Note**: This documentation was generated by AI and may contain inaccuracies. Please verify information and refer to the source code for authoritative details.

# Branched Pipeline

## Overview

A **Branched Pipeline** (`BranchedPipeline`) executes foremen in a tree structure, allowing multiple execution paths from a single source. This enables complex workflows with branching logic.

## Architecture

```
                    Head (Search)
                   /     |     \
              Channels  Videos  Playlists
                 |        |        |
            Playlists  Comments  PlaylistItems
                 |        |           |
          PlaylistItems  Captions    Videos
                 |
               Videos
```

Each node can have multiple children, creating a tree structure.

## Construction

### Using String Notation

```python
from yt_pipeline.pipeline.tree import PipelineBlockNodeConstructor, BranchedPipelineStacks, BranchedPipeline
from yt_pipeline.retriever import RetrieverSettings, SearchParamProps

constructor = PipelineBlockNodeConstructor(
    retriever_settings=RetrieverSettings(multithread=True)
)

# Create head node
head = constructor.construct("search(channel,playlist,video)<save_output max_page(1)>")

# Create branches
head.connect("channels<save_output>").connect(
    "playlists<save_output max_page(1)>").connect(
    "playlist_items<save_output>").connect(
    "videos<save_output>"
)

head.connect("playlists<save_output max_page(1)>").connect(
    "playlist_items<save_output>"
)

# Videos branch with multiple children
videos_head = constructor.construct("videos<save_output>")
videos_head.connect("comments<save_output max_page(1)>")
videos_head.connect("captions<save_output>")
head.connect(videos_head)

# Create and execute
stacks = BranchedPipelineStacks(
    initial_input=[SearchParamProps(q="music")],
    head=head
)

branched_pipeline = BranchedPipeline(stacks=stacks, developerKey=devKey)
result = branched_pipeline.invoke()
```

## Execution Flow

1. **Head Execution** — Executes head node with initial input
2. **Branch Execution** — For each child node:
   - Extracts IDs from parent output
   - Executes child node with extracted IDs
   - Recursively executes child's children
3. **Tree Traversal** — Executes nodes in depth-first order
4. **Output Collection** — Collects outputs from all nodes

## Output Structure

Returns `BranchedPipelineDeliverable`:

```python
result.head_product  # PipelineProductNode (tree structure)
result.report        # BranchedPipelineExecutionReport
```

The `head_product` is a tree where:

- Each node is a `PipelineProductNode`
- `links` contains child products
- `shipper` contains data (if `save_output=True`)

## Example: Complex Workflow

```python
from yt_pipeline.pipeline.tree import PipelineBlockNodeConstructor, BranchedPipelineStacks, BranchedPipeline
from yt_pipeline.retriever import RetrieverSettings, SearchParamProps

constructor = PipelineBlockNodeConstructor(
    retriever_settings=RetrieverSettings(multithread=True)
)

# Search for channels
head = constructor.construct("search(channel)<save_output max_page(1)>")

# Branch 1: Channels → Playlists → Items → Videos
head.connect("channels<save_output>").connect(
    "playlists<save_output max_page(2)>").connect(
    "playlist_items<save_output>").connect(
    "videos<save_output>"
)

# Branch 2: Direct playlists from search
head.connect("playlists<save_output max_page(1)>").connect(
    "playlist_items<save_output>"
)

# Create and execute
stacks = BranchedPipelineStacks(
    initial_input=[SearchParamProps(q="programming")],
    head=head
)

pipeline = BranchedPipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()

# Access tree structure
def print_tree(node, indent=0):
    print("  " * indent + node.title)
    if node.shipper:
        print("  " * indent + f"  Items: {len(node.shipper.main_records)}")
    for child in node.links:
        print_tree(child, indent + 1)

print_tree(result.head_product)
```

## Node Connection

Nodes are connected using `.connect()`:

```python
node1.connect("videos<save_output>")  # Connect using string notation
node1.connect(node2)                    # Connect using node object
```

## Settings

Each node can have:

- `foreman`: Foreman instance
- `pipe_settings`: Pagination settings
- `retriever_settings`: Execution settings
- `save_output`: Save this node's output
- `backup_shipper`: Backup shipper data
- `max_workers`: Number of concurrent threads
- `debug`: Enable debug logging

## Quota Estimation

```python
from yt_pipeline.pipeline.tree import BranchedPipelineEstimator

estimator = BranchedPipelineEstimator(pipeline=branched_pipeline)
report = estimator.estimate()
report.display(metrics="all")
```

## Best Practices

1. **Plan Tree Structure** — Design your tree before building
2. **Use String Notation** — Easier for rapid prototyping
3. **Save Outputs** — Use `save_output=True` to capture data at each node
4. **Limit Branches** — Too many branches can lead to high quota usage
5. **Estimate First** — Always estimate quota before execution

## When to Use Branched Pipelines

### Use Branched Pipelines When:

- You need multiple execution paths from one source
- You want to process data in parallel branches
- You have complex workflows with branching logic
- You need to explore multiple data paths

### Use Linear Pipelines When:

- You have a simple sequential workflow
- You don't need branching
- You want simpler code and easier debugging

## Related Documentation

- **[Linear Pipeline](./linear-pipeline.md)** — Sequential pipelines
- **[Pipeline Estimator](./pipeline-estimator.md)** — Quota estimation
- **[Pipeline Constructor](./pipeline-constructor.md)** — String notation guide
- **[Use Cases](./use-cases.md)** — Practical examples

## Next Steps

- Learn about [Linear Pipelines](./linear-pipeline.md) for sequential workflows
- Read about [Pipeline Use Cases](./use-cases.md) for more examples
