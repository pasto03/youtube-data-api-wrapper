> **Note**: This documentation was generated by AI and may contain inaccuracies. Please verify information and refer to the source code for authoritative details.

# Pipeline Use Cases

This document provides practical examples of building and using pipelines.

## Common Patterns

### Pattern 1: Search → Details

Search for content and get full details:

```python
from yt_pipeline.pipeline import Pipeline, PipelineStacks, PipelineBlocksConstructor
from yt_pipeline.retriever import RetrieverSettings, PipeSettings, SearchParamProps

constructor = PipelineBlocksConstructor(
    retriever_settings=RetrieverSettings(multithread=True),
    pipe_settings=PipeSettings(max_page=1)
)

pipeline_blocks = constructor.construct(
    "search(video)<save_output max_page(1)> -> videos<save_output>"
)

stacks = PipelineStacks(
    initial_input=[SearchParamProps(q="python tutorial")],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

### Pattern 2: Channel → Playlists → Videos

Get all videos from a channel's playlists:

```python
pipeline_blocks = constructor.construct(
    "channels<save_output> -> playlists<save_output max_page(10)> -> playlist_items<save_output> -> videos<save_output>"
)

stacks = PipelineStacks(
    initial_input=["UC_x5XG1OV2P6uZZ5FSM9Ttw"],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

### Pattern 3: Videos → Comments

Get comments for videos:

```python
pipeline_blocks = constructor.construct(
    "videos<save_output> -> comments<save_output max_page(3)>"
)

stacks = PipelineStacks(
    initial_input=["dQw4w9WgXcQ", "jNQXAC9IVRw"],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

## Detailed Examples

### Example 1: Content Discovery Pipeline

Search for videos, get details, and analyze comments:

```python
from yt_pipeline.pipeline import Pipeline, PipelineStacks, PipelineBlocksConstructor, PipelineEstimator
from yt_pipeline.retriever import RetrieverSettings, PipeSettings, SearchParamProps

constructor = PipelineBlocksConstructor(
    retriever_settings=RetrieverSettings(multithread=True),
    pipe_settings=PipeSettings(max_page=1)
)

pipeline_blocks = constructor.construct(
    "search(video)<save_output max_page(1)> -> videos<save_output> -> comments<save_output max_page(1)>"
)

stacks = PipelineStacks(
    initial_input=[SearchParamProps(q="python tutorial", order="viewCount")],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)

# Estimate first
estimator = PipelineEstimator(pipeline)
report = estimator.estimate()
report.display(metrics="all")

# Execute
result = pipeline.invoke()

# Access results
for product in result.products:
    print(f"{product.title}: {len(product.shipper.main_records)} items")
```

### Example 2: Channel Analysis Pipeline

Analyze a channel's content structure:

```python
pipeline_blocks = constructor.construct(
    "channels<save_output> -> playlists<save_output max_page(20)> -> playlist_items<save_output max_page(1)>"
)

stacks = PipelineStacks(
    initial_input=["UC_x5XG1OV2P6uZZ5FSM9Ttw"],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()

# Analyze channel structure
channel_data = result.products[0].shipper.main_records[0]
playlists_data = result.products[1].shipper.main_records

print(f"Channel: {channel_data['title']}")
print(f"Playlists: {len(playlists_data)}")
```

### Example 3: Branched Analysis

Use branched pipeline to explore multiple paths:

```python
from yt_pipeline.pipeline.tree import PipelineBlockNodeConstructor, BranchedPipelineStacks, BranchedPipeline
from yt_pipeline.retriever import RetrieverSettings, SearchParamProps

constructor = PipelineBlockNodeConstructor(
    retriever_settings=RetrieverSettings(multithread=True)
)

head = constructor.construct("search(channel,video)<save_output max_page(1)>")

# Branch 1: Channels → Playlists
head.connect("channels<save_output>").connect("playlists<save_output max_page(5)>")

# Branch 2: Videos → Comments
head.connect("videos<save_output>").connect("comments<save_output max_page(1)>")

stacks = BranchedPipelineStacks(
    initial_input=[SearchParamProps(q="programming")],
    head=head
)

pipeline = BranchedPipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

## Best Practices

1. **Estimate First** — Always estimate quota before execution
2. **Save Intermediate Results** — Use `save_output=True` to capture data at each step
3. **Limit Pagination** — Use `max_page` to control result size
4. **Enable Multithreading** — Use `multithread=True` for better performance
5. **Handle Errors** — Check `pipeline.pipeline_errors` for execution errors
6. **Use String Notation** — For prototyping, switch to objects for production

## Related Documentation

- **[Linear Pipeline](./linear-pipeline.md)** — Sequential pipelines
- **[Branched Pipeline](./branched-pipeline.md)** — Tree-based pipelines
- **[Pipeline Estimator](./pipeline-estimator.md)** — Quota estimation
- **[Pipeline Constructor](./pipeline-constructor.md)** — String notation

## Next Steps

- Learn about [Linear Pipelines](./linear-pipeline.md) for sequential workflows
- Explore [Branched Pipelines](./branched-pipeline.md) for complex workflows
