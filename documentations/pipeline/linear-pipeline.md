> **Note**: This documentation was generated by AI and may contain inaccuracies. Please verify information and refer to the source code for authoritative details.

# Linear Pipeline

## Overview

A **Linear Pipeline** (`Pipeline`) executes multiple foremen sequentially, where each step's output feeds into the next step. It's the simplest and most common pipeline type.

## Architecture

```
Initial Input → Foreman₁ → Extract IDs → Foreman₂ → Extract IDs → ... → Final Output
```

Each step:

1. Executes a foreman with input IDs/params
2. Extracts relevant IDs from the output
3. Passes those IDs as input to the next step

## Connection Rules

Valid sequential connections:

- `search` → `videos`, `channels`, `playlists`, `playlist_items`, `search`
- `channels` → `playlists`
- `playlists` → `playlist_items`
- `playlist_items` → `videos`
- `videos` → `comments`, `captions`

## Construction Methods

### Method 1: Object Notation

```python
from yt_pipeline.pipeline import Pipeline, PipelineBlock, PipelineStacks
from yt_pipeline.foreman import SearchForeman, VideosForeman, CommentThreadsForeman
from yt_pipeline.retriever import RetrieverSettings, PipeSettings, SearchParamProps, SearchTypeCheckboxProps

stacks = PipelineStacks(
    initial_input=[SearchParamProps(q="python tutorial")],
    blocks=[
        PipelineBlock(
            foreman=SearchForeman(types=SearchTypeCheckboxProps(video=True)),
            pipe_settings=PipeSettings(max_page=1),
            retriever_settings=RetrieverSettings(multithread=True),
            max_workers=8
        ),
        PipelineBlock(
            foreman=VideosForeman(),
            retriever_settings=RetrieverSettings(multithread=True)
        ),
        PipelineBlock(
            foreman=CommentThreadsForeman(),
            pipe_settings=PipeSettings(max_page=2),
            retriever_settings=RetrieverSettings(multithread=True)
        )
    ]
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

### Method 2: String Notation

```python
from yt_pipeline.pipeline import Pipeline, PipelineStacks, PipelineBlocksConstructor
from yt_pipeline.retriever import RetrieverSettings, PipeSettings, SearchParamProps

constructor = PipelineBlocksConstructor(
    retriever_settings=RetrieverSettings(multithread=True),
    pipe_settings=PipeSettings(max_page=1)
)

pipeline_blocks = constructor.construct(
    "search(video)<save_output max_page(1)> -> videos<save_output> -> comments<save_output max_page(2)>"
)

stacks = PipelineStacks(
    initial_input=[SearchParamProps(q="python tutorial")],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)
result = pipeline.invoke()
```

## Execution Flow

1. **Initial Input** — Pipeline starts with `initial_input`
2. **Block Execution** — Each block executes its foreman with current input
3. **ID Extraction** — Pipeline extracts IDs from block output
4. **Next Input** — Extracted IDs become input for next block
5. **Output Saving** — If `save_output=True`, block output is saved
6. **Final Output** — Last block's output is returned

## Output Structure

Returns `PipelineDeliverable`:

```python
result.products  # List of PipelineProduct objects (one per saved block)
result.report    # PipelineExecutionReport with metrics
```

Each product contains:

- `title`: Foreman name
- `shipper`: Shipper object with data

## Example: Search → Videos → Comments

```python
from yt_pipeline.pipeline import Pipeline, PipelineStacks, PipelineBlocksConstructor
from yt_pipeline.retriever import RetrieverSettings, PipeSettings, SearchParamProps

constructor = PipelineBlocksConstructor(
    retriever_settings=RetrieverSettings(multithread=True),
    pipe_settings=PipeSettings(max_page=1)
)

pipeline_blocks = constructor.construct(
    "search(video)<save_output max_page(1)> -> videos<save_output> -> comments<save_output max_page(1)>"
)

stacks = PipelineStacks(
    initial_input=[SearchParamProps(q="python tutorial")],
    blocks=pipeline_blocks
)

pipeline = Pipeline(stacks=stacks, developerKey=devKey)

# Estimate quota
from yt_pipeline.pipeline import PipelineEstimator
estimator = PipelineEstimator(pipeline)
report = estimator.estimate()
report.display(metrics="all")

# Execute
result = pipeline.invoke()

# Access results
for product in result.products:
    print(f"{product.title}: {len(product.shipper.main_records)} items")
```

## Settings

### PipelineBlock Settings

- `foreman`: Foreman instance
- `pipe_settings`: Pagination settings (for iterable foremen)
- `retriever_settings`: Execution settings
- `save_output`: Save this block's output to deliverables
- `backup_shipper`: Backup shipper data to files
- `max_workers`: Number of concurrent threads
- `debug`: Enable debug logging

## Error Handling

- **Validation Errors**: Raised during construction if blocks can't be connected
- **Execution Errors**: Stored in `pipeline.pipeline_errors`
- **Early Termination**: Pipeline stops if a block returns no items

## Best Practices

1. **Estimate First** — Always estimate quota before execution
2. **Save Intermediate Results** — Use `save_output=True` to capture data at each step
3. **Limit Pagination** — Use `max_page` to control result size
4. **Enable Multithreading** — Use `multithread=True` for better performance
5. **Use String Notation** — For rapid prototyping, switch to object notation for production

## Related Documentation

- **[Branched Pipeline](./branched-pipeline.md)** — Tree-based pipelines
- **[Pipeline Estimator](./pipeline-estimator.md)** — Quota estimation
- **[Pipeline Constructor](./pipeline-constructor.md)** — String notation guide
- **[Use Cases](./use-cases.md)** — Practical examples

## Next Steps

- Learn about [Branched Pipelines](./branched-pipeline.md) for complex workflows
- Read about [Pipeline Use Cases](./use-cases.md) for more examples
